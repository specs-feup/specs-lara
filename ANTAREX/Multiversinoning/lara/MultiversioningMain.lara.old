import manet.util.Util;

/**
 *	Changes an application in order to generate several clones of a target function.
 * 	Each clone will have a different optimization level and different OpenMP configurations.
 * 	Finally, this strategy also replaces the call to the target function with a call to a wrapper
 * which will select the correct clone based on the current configuration (global variables).
**/

aspectdef MultiversioningMain

	input
		globalNameOpt = "opt_level",				// name of the global var holding the optimization level
		optLevels = ["O0", "O1", "O2", "O3", "Os"],	// possible optimization levels
		globalNameBind = "proc_bind",				// name of the global var holding the proc_bind policy
		procBindOptions = ['close', 'spread'],		// possible proc_bind policies
		globalNameThreads = "num_threads",			// name of the global var holding the number of threads
		targetFunction = 'kernel_2mm',			// name of the target function
		targetLoop = 't2',						// name of the control variable of the target loop inside the target function
		privateVars = ['lbv','ubv','t3','t4','t5'],	// name of the vars that need to be private inside the OpenMP loop
		wrapperName							// name of the target function wrapper
	end

	if(wrapperName == undefined) {
		wrapperName = targetFunction + '_wrapper';
	}

	// get original args and params of the target function
	call od: GetOriginalData(targetFunction);
	var originalArgs = od.originalArgs;
	var originalParams = od.originalParams;
	var returnType = od.returnType;

	// generate clones according to the optimization levels
	call gc: GenerateClones(targetFunction, optLevels, procBindOptions);
	var clonedFunctions = gc.clonedFunctions;

	// insert optimization pragmas in each cloned function
	call InsertOptPragmas(clonedFunctions);

	// insert OpenMP directive in each cloned function
	call InsertOmpPragmas(clonedFunctions, globalNameThreads, targetLoop, privateVars, procBindOptions);

	// insert global variables
	call PrepareData(globalNameThreads, globalNameOpt, globalNameBind, targetFunction);

	// generares and inserts the wrapper function and changes the call to the original function to the wrapper
	call GenerateWrapper(	targetFunction,
						returnType,
						wrapperName,
						originalArgs,
						originalParams,
						globalNameThreads,
						globalNameOpt,
						globalNameBind,
						optLevels,
						procBindOptions);
end


aspectdef GenerateClones
	input
		targetFunction,
		optLevels,
		procBindOptions
	end
	output
		clonedFunctions = {}
	end

	println("\t Generating clones");

	select function{targetFunction} end
	apply
		for (var bind of procBindOptions) {
			for(var opt of optLevels) {
				var newName = targetFunction + '_' + bind + '_' + opt;
				exec Clone(newName);
				clonedFunctions[newName] = {'opt': opt, 'bind': bind};
			}
		}
	end
end

aspectdef InsertOptPragmas
	input
		clonedFunctions
	end

	println("\t Inserting opt pragmas");

	select function end
	apply
		var clone = clonedFunctions[$function.name];
		if(clone !== undefined) {
		
			insert before %{
				#pragma GCC push_options
				#pragma GCC optimize ("[[clone.opt]]")
			}%;
			insert after %{
				#pragma GCC pop_options
			}%;
		}
	end
end

aspectdef GetOriginalData

	input
		targetFunction
	end
	output
		originalArgs,
		originalParams,
		returnType
	end

	println("\t Getting original data");

	var foundCall = false;
	select call{targetFunction} end
	apply
		originalArgs = $call.argList.join(',');
		// find return type of target
		returnType = $call.return_type;

		foundCall = true;
	end

	if(!foundCall) {

		// println('\t\t ERROR: Could not find call to function "' + targetFunction + '"');
		throw 'ERROR: Could not find call to function "' + targetFunction + '"';
	}

	var foundFunction = false;
	select function{targetFunction} end
	apply
		originalParams = $function.fullParamList.join(',');

		foundFunction = true;
	end

	
	if(!foundFunction) {

		// println('\t\t ERROR: Could not find function "' + targetFunction + '"');
		throw 'ERROR: Could not find function "' + targetFunction + '"';
	}
end

aspectdef InsertOmpPragmas

	input
		clonedFunctions,
		globalNameThreads,
		targetLoop,
		privateVars,
		procBindOptions
	end

	println("\t Inserting OpenMP pragmas");

	select function.loop end
	apply
		
		var clone = clonedFunctions[$function.name];
		if(clone !== undefined) {

			// build the private clause
			var privateClause = '';
			if(privateVars == undefined || privateVars.length != 0) {
				privateClause = 'private(' + privateVars.join(',') + ') ';
			}

			// build the proc_bind clause
			var procBindClause = 'proc_bind(' + clone.bind + ')';

			// insert the actual OpenMP pragma
			if($loop.control_var == targetLoop) {

				insert before %{
            			#pragma omp parallel for [[privateClause]]num_threads([[globalNameThreads]]) [[procBindClause]]
				}%;

				clonedFunctions[$function.name].foundLoop = true;
			}
		}
	end
	for (var cloneName in clonedFunctions) {

		var clone = clonedFunctions[cloneName];
		if (!clone.foundLoop) {
			throw 'ERROR: Could not find target loop "' + targetLoop + '" inside function "' + cloneName + '"';
		}
	}
end

aspectdef PrepareData

	input
		globalNameThreads,
		globalNameOpt,
		globalNameBind,
		targetFunction
	end

	println("\t Preparing data");
	
	var intType = new CTypeBuilder()
				.base('int')
				.build();

	// define and declare a global variable to hold the number of OpenMP threads
	select file end
	apply						
		exec AddGlobal([[globalNameThreads]], intType, "4");
		exec AddGlobal([[globalNameOpt]], intType, "0");
		exec AddGlobal([[globalNameBind]], intType, "0");
	end
end

aspectdef GenerateWrapper
	input
		targetFunction,
		returnType,
		wrapperName,
		originalArgs,
		originalParams,
		globalNameThreads,
		globalNameOpt,
		globalNameBind,
		optLevels,
		procBindOptions
	end

	println("\t Generating wrapper");
	println("\t\t return type: " + returnType);

	select call{targetFunction} end
	apply
		def name = wrapperName;
	end

	// generate switch code
	var newArgs = originalArgs.split('&').join('');
	var newArgs = originalArgs.split('*').join('');

	var bindCode = 'switch(' + globalNameBind + ') {\n';
	for (var bindId in procBindOptions) {

		var bindStr = procBindOptions[bindId];

		bindCode += 'case ' + bindId + ': //' + bindStr + '\n';

		// build the switch statement for the optimization levels
		var optCode = 'switch(' + globalNameOpt + ') {\n';
		for(var optId in optLevels) {
	
			var optStr = optLevels[optId];
			var cloneName = targetFunction + '_' + bindStr + '_' + optStr;
			
			optCode += 'case ' + optId + ': //' + optStr + '\n';
			if(returnType == 'void') {
				optCode += '\t' + cloneName + '(' + newArgs +');\n\tbreak;\n';
			} else {
				optCode += '\treturn ' + cloneName + '(' + newArgs +');\n';
			}
		}
		if(returnType == 'void') {
		
			optCode += 'default:\n' + targetFunction + '(' + newArgs + ');\n\tbreak;\n}';
		} else {
			optCode += 'default:\nreturn ' + targetFunction + '(' + newArgs + ');\n}';
		}

		bindCode += optCode;
		bindCode += '\nbreak;\n';
	}
	bindCode += 'default:\n' + targetFunction + '(' + newArgs + ');\n\tbreak;\n}';

	
	// generate wrapper
	var wrapper = returnType + ' ' + wrapperName + '(' + originalParams + ') {\n';
	wrapper += bindCode;
	wrapper += '\n}\n';

	select function{'main'} end
	apply
		insert before wrapper;
	end
end
