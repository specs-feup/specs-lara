import antarex.margot.config.monitor.MargotTimeMonitor;
import antarex.margot.config.monitor.MargotEnergyMonitor;
import antarex.margot.config.monitor.MargotThroughputMonitor;
import antarex.margot.config.MargotState;
import antarex.margot.config.MargotKnob;
import antarex.margot.config.MargotDataFeature;

/**
 * This holds information about a mARGOt configuration block.
 * */
function MargotBlock(name) {
    
    this._name = name;
    this._knobs = [];
    this._goals = [];
    this._monitors = [];
    this._states = [];
    this._metrics = [];
    this._runtimes = [];
    this._features = undefined;
}

/**
 * Sets the distance type of the feature group of this block.
 * 
 * @param {MargotDistanceType} distanceType - the type of distance calculation for data features
 * */
MargotBlock.prototype.setDataFeatureDistanceType = function(distanceType) {
	
	if(this._features === undefined) {
		
		this._features = orDefault(this._features, new MargotDataFeatureGroup(distanceType));
	} else {
		
		this._features.setDistanceType(distanceType);
	}
}

/**
 * Adds a new feature to the feature group of this block.
 * 
 * If it wasn't defined before, a new group will be created with a default distance type value of MargotDistanceType.EUCLIDEAN.
 * 
 * @param {string} name - the name of the variable that holds the value of the data feature
 * @param {string} type - the type of the variable that holds the value of the data feature
 * @param {MargotValidity} [validity='-'] - the comparison used to test the validity
 * */
MargotBlock.prototype.addDataFeature = function(name, type, validity) {
	
	this._features = orDefault(this._features, new MargotDataFeatureGroup(MargotDistanceType.EUCLIDEAN));
	
	this._features.addFeature(name, type, validity);
}

/**
 * Adds a knob to the block with the given data.
 * */
MargotBlock.prototype.addKnob = function(name, varName, varType) {
    
    if(name === undefined || varName === undefined || varType === undefined) {
        
        throw 'To define a knob you need a name, a variable name and a variable type.';
    }
    
    this._knobs.push(new MargotKnob(name, varName, varType));
};

/**
 * Adds a metric to the block with the given data.
 * */
MargotBlock.prototype.addMetric = function(name, type, distribution) {

    if(name === undefined || type === undefined || distribution === undefined) {
        
        throw 'To define a metric you need a name, a type and a distribution.';
    }
    
    this._metrics.push({name: name, type: type, distribution: distribution});
}

/**
 * Adds a runtime information provider to the block with the given data.
 * */
MargotBlock.prototype.addRuntimeProvider = function(metricName, monitorName, inertia) {

    if(metricName === undefined || monitorName === undefined || inertia === undefined) {
        
        throw 'To define a runtime information provider you need a metric name, a monitor name and an inertia value.';
    }
    
    this._runtimes.push({metricName: metricName, monitorName: monitorName, inertia: inertia});
}

/**
 * Enum for metric definition.
 * */
var MargotDistribution = new Enumeration('YES', 'NO');

/**
 * Adds a monitor goal to the block with the given data.
 * */
MargotBlock.prototype.addMonitorGoal = function(name, cFun, value, monitor, dFun) {
    
    for(var arg of arguments) {
        
        if(arg === undefined) {
            throw 'To define a monitor goal you need a name, a cFun, a value, a monitor name and a dFun.';
        }
    }
    
    this._goals.push(new MargotMonitorGoal(name, cFun, value, monitor, dFun));
};

/**
 * Adds a metric goal to the block with the given data.
 * */
MargotBlock.prototype.addMetricGoal = function(name, cFun, value, metric) {
    
    for(var arg of arguments) {
        
        if(arg === undefined) {
            throw 'To define a metric goal you need a name, a cFun, a value and a metric name.';
        }
    }
    
    this._goals.push(new MargotMetricGoal(name, cFun, value, metric));
};

/**
 * Adds a knob goal to the block with the given data.
 * */
MargotBlock.prototype.addKnobGoal = function(name, cFun, value, knob) {
    
    for(var arg of arguments) {
        
        if(arg === undefined) {
            throw 'To define a knob goal you need a name, a cFun, a value and a knob name.';
        }
    }
    
    this._goals.push(new MargotKnobGoal(name, cFun, value, knob));
};

/**
 * @constructor
 * 
 * A generic goal.
 * */
function MargotGoal(name, cFun, value) {
	
	/* TODO: check parameters */
	
	this._name = name;
	this._cFun = cFun;
	this._value = value;
	
	this._makeCode = function(additionalCode) {
		
		return _GoalTemplate(this._name, this._cFun, this._value, additionalCode);
	};
}

/**
 * @constructor
 * 
 * A monitor goal.
 * */
function MargotMonitorGoal(name, cFun, value, monitor, dFun) {
	
	/* TODO: check parameters */
	
	this._baseGoal = new MargotGoal(name, cFun, value);
	this._monitor = monitor;
	this._dFun = dFun;
	
	this._makeCode = function() {
		
		var monitorCode = 'monitor="' + this._monitor + '" dFun="' + this._dFun + '"';
		return this._baseGoal._makeCode(monitorCode);
	};
}

/**
 * @constructor
 * 
 * A knob goal.
 * */
function MargotKnobGoal(name, cFun, value, knob) {
	
	/* TODO: check parameters */
	
	this._baseGoal = new MargotGoal(name, cFun, value);
	this._knob = knob;
	
	this._makeCode = function() {
		
		var monitorCode = 'knob_name="' + this._knob + '"';
		return this._baseGoal._makeCode(monitorCode);
	};
}

/**
 * @constructor
 * 
 * A metric goal.
 * */
function MargotMetricGoal(name, cFun, value, metric) {
	
	/* TODO: check parameters */
	
	this._baseGoal = new MargotGoal(name, cFun, value);
	this._metric = metric;
	
	this._makeCode = function() {
		
		var monitorCode = 'metric_name="' + this._metric + '"';
		return this._baseGoal._makeCode(monitorCode);
	};
}

/**
 * Enums for the function definitions of goal in mARGOt.
 * */
var MargotDFun = new Enumeration({
	AVG: 'AVERAGE',
	VAR: 'VARIANCE',
	MAX: 'MAX',
	MIN: 'MIN'
});
var MargotCFun = new Enumeration('LT','LE','GT','GE');

/**
 * Adds a monitor to the block.
 * */
MargotBlock.prototype.addMonitor = function(monitor) {
    
    this._monitors.push(monitor);
}

/**
* Builds an energy monitor, adds it to the list of monitors, and returns it.
* */
MargotBlock.prototype.newEnergyMonitor = function(name) {
    var em = new MargotEnergyMonitor(name);
    this._monitors.push(em);
    return em;
}

/**
* Builds a time monitor, adds it to the list of monitors, and returns it.
* */
MargotBlock.prototype.newTimeMonitor = function(name) {
    var tm = new MargotTimeMonitor(name);
    this._monitors.push(tm);
    return tm;
}

/**
* Builds a throughput monitor, adds it to the list of monitors, and returns it.
* */
MargotBlock.prototype.newThroughputMonitor = function(name, param1, param2) {
    
    checkDefined(name, 'name', 'newThroughputMonitor');
    checkDefined(param1, 'param1', 'newThroughputMonitor');
    
    var tpm = undefined;
    
	if(param2 !== undefined) {
		tpm = new MargotThroughputMonitor(name, param1, param2);
    } else {
		tpm = new MargotThroughputMonitor(name, param1);
	}
    this._monitors.push(tpm);
    return tpm;
}

/**
 * Adds a state to the list of states.
 * */
MargotBlock.prototype.addState = function (state) {
    
    this._states.push(state);
}

/**
* Builds a state, adds it to the list of states, and returns it.
* */
MargotBlock.prototype.newState = function(name) {
    var s = new MargotState(name);
    this._states.push(s);
    return s;
}

/*
 * CODE GENERATION
 * ****************************************************************************/

/**
 * Generates code for the entire block.
 * */
MargotBlock.prototype._makeCode = function() {
    
    var code = '<block name="' + this._name + '">\n';
    
    code += this._makeMonitorsCode();
    code += this._makeKnobsCode();
    code += this._makeMetricsCode();
    code += this._makeFeaturesCode();
    code += this._makeRuntimesCode();
    code += this._makeGoalsCode();
    code += this._makeStatesCode();
    
    code += '</block>\n';
    
    return code;
}

/**
* Generates the code of the features.
* */
MargotBlock.prototype._makeFeaturesCode = function() {
	
	if(this._features === undefined) {
		return '';
	}
	
	var code = '<!-- FEATURE SECTION -->\n';
	
	code += this._features._makeCode();
	
	return code;
}

/**
* Generates the code of the monitors.
* */
MargotBlock.prototype._makeMonitorsCode = function() {
    
    var code = '<!-- MONITOR SECTION -->\n';
    
    for (var monitor of this._monitors) {
    
        code += monitor._makeCode();
    }
    
    return code;
}

/**
* Generates the code of the goals.
* */
MargotBlock.prototype._makeGoalsCode = function() {
    
    var code = '<!-- GOAL SECTION -->\n';
    
    for (var goal of this._goals) {
    
        code += goal._makeCode() + '\n';
    }
    
    return code;
}

/**
* Generates the code of the software knobs.
* */
MargotBlock.prototype._makeKnobsCode = function() {
    
    var code = '<!-- SW-KNOB SECTION -->\n';
    
    for (var knob of this._knobs) {
    
        code += _KnobTemplate(knob.getName(), knob.getVarName(), knob.getVarType());
    }
    
    return code;
}

/**
* Generates the code of the metrics.
* */
MargotBlock.prototype._makeMetricsCode = function() {
    
    var code = '<!-- METRIC SECTION -->\n';
    
    for (var metric of this._metrics) {
    
        code += _MetricTemplate(metric.name, metric.type, metric.distribution);
    }
    
    return code;
}

/**
* Generates the code of the runtime information providers.
* */
MargotBlock.prototype._makeRuntimesCode = function() {
    
    var code = '<!-- RUNTIME INFORMATION PROVIDER -->\n';
    
    for (var runtime of this._runtimes) {
    
        code += _RuntimeTemplate(runtime.metricName, runtime.monitorName, runtime.inertia);
    }
    
    return code;
}

/**
* Generates the code of the states.
* */
MargotBlock.prototype._makeStatesCode = function() {
    
    var code = '<!-- OPTIMIZATION SECTION -->\n';
    
    for (var state of this._states) {
    
        code += state._makeCode();
    }
    
    return code;
}

/*
 * TEMPLATES
 * ****************************************************************************/

/**
 * Template used for the generation of the XML code for knobs.
 * */
codedef _KnobTemplate(param1, param2, param3) %{
<knob name="[[param1]]" var_name="[[param2]]" var_type="[[param3]]"/> 
}%
end

/**
 * Template used for the generation of the XML code for metrics.
 * */
codedef _MetricTemplate(param1, param2, param3) %{
<metric name="[[param1]]" type="[[param2]]" distribution="[[param3]]"/> 
}%
end

/**
 * Template used for the generation of the XML code for runtime information providers.
 * */
codedef _RuntimeTemplate(param1, param2, param3) %{
<metric metric_name="[[param1]]" using="[[param2]]" inertia="[[param3]]"/> 
}%
end

/**
 * Template used for the generation of the XML code for goals.
 * */
codedef _GoalTemplate(name, cFun, value, additionalCode) %{
<goal name="[[name]]" cFun="[[cFun]]" value="[[value]]" [[additionalCode]]/> 
}%
end
