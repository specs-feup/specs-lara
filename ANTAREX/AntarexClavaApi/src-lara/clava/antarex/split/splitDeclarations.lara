
import antarex.utils.IdentReferences;

var LOC_DEBUG_MODE=false;
var $SPLIT_CPT_ID = 0;
var $SPLIT_NEW_ID = "FOO";

/**
	@return true if the identifier of a declaration ($decl) may not be replaced, false otherwise.
    Return true for 
       - global variable, 
       - reference to a member of a class.
*/
function isfilteredDeclaration($decl) {
   if ($decl.getValue("hasGlobalStorage")) return true;
   if ($decl.getValue("isCXXClassMember")) return true;
   return false;
}

/**
	Substitute the name of the symbol of a declaration, element of $Decls, by a new name.
	The operation is not applied for some declarations (global one, member of classes,...).
  */
function substituteSymbols($Decls) {
	TRACE_HERE( "  substituteSymbols BEGIN");
    for (var $f of $Decls)  {
       if ( isfilteredDeclaration($f))
	 	 TRACE_HERE( "  Nothing to do for " + $f.code + "  ( GlobalStorage, CXXClassMember,...) ");
       else
		{
          TRACE_HERE(" substitute For " + $f.code + " at location " +  $f.location);
          substituteIdentDeclaration($f);
		}
    }
   TRACE_HERE( "  substituteSymbols END");
}


/** 
  Assign a new ident to a declaration ($decl).
*/
function substituteIdentDeclaration($decl)
{
  $decl.setName(getNewId($decl.name));
}

/**
  Declare as global the declaration element of $Decls.
  The operation is not applied for some declarations (global one, member of classes,...).
 */
function declNewSymbolsAsGlobals($Decls)
{
 var op="DeclNewSymbolsAsGlobals";
 
 TRACE_HERE( "  " + op + " BEGIN");
 for (var $f of $Decls)  {
   if ( isfilteredDeclaration($f))
	  TRACE_HERE( "  Nothing to do for " + $f.code + "  ( GlobalStorage, CXXClassMember,...) ");
   else
	 {
	  TRACE_HERE(" declaration = " + $f.code + " at " + $f.location);
      var $currentFunction = getFunctionOrMethod($f);
      $currentFunction.insertBefore(removeInitDecl($f.copy()));
	 }
  }
  TRACE_HERE( "  " + op + " END");
}

/**
  Keep initialisation assigned to a declaration, element of $Decls, as a new statement
  The operation is not applied for some declarations (global one, member of classes) 
  and not for an index variable of a loop.
  
  Example:
   For a declaration such that {...; int i = 88; ...}, it produces {...; i = 88; int i = 88; ...}

*/
function keepInitDeclarations($Decls)
{
  var op="KeepInitDeclarations";
  
  TRACE_HERE( "  " + op + " BEGIN");
    for (var $f of $Decls)  {
	  if ( ! isfilteredDeclaration($f)) {
		  TRACE_HERE(" Declaration = " + $f.code + " at " + $f.location);
          if ($f.astName === 'VarDecl')  
 	       if ( ! $f.isInsideLoopHeader) 
 	          { 
 	           if ($f.hasInit)
 	             { 
  		          var $father = $f.astParent;  // DeclStmt 
  		          $father.insert before $f.name + ' = ' + $f.init.code + ';';
  		         }
  		      }
  		      else;
		 }
    }
    TRACE_HERE( "  " + op + " END");
}

/**
  Remove the declaration, element of $Decls, from the code.
  The operation is not applied for some declarations (global one, member of classes).
*/
function cleanCode($Decls)
{
    TRACE_HERE( "  cleanCode BEGIN");
    for (var $f of $Decls)  {
	  if (! isfilteredDeclaration($f)) {
       var $DeclStmt = $f.astParent; //DeclStmt
         if ( ! $f.isInsideLoopHeader)
         	{
         	  if ($DeclStmt.astNumChildren === 1) $DeclStmt.detach(); else $f.detach();
         	}
	       else 
	        {  		         
  		      var $DeclStmt = $f.astParent;  // DeclStmt 
  		      var $vloop = $DeclStmt.astParent;  
         	  if ($vloop.astIsInstance('ForStmt'))
              if ($vloop.astChild(0).location === $DeclStmt.location)
                $vloop.setInit ( $f.name + ' = ' + $f.init.code );
              else
                NYI("cleanCode for " + $f.code + " at " + $f.location);
  		    }
      }
    }
    TRACE_HERE( "  cleanCode END");
}

/**
  Remove the initial value assigned to a declaration.
*/
function removeInitDecl($vdecl) {
 if ($vdecl.astName === 'VarDecl')  
 	if ($vdecl.hasInit)
  		$vdecl.init.detach();
  return $vdecl;
}

/**
  Remove the initialisations of a decl statement.
 */
function removeInit($vstmt) {
	for (var $vdecl of $vstmt.astChildren) {
	   removeInitDecl($vdecl);
	}
	return $vstmt;
}

/**
  Import in a file ($afile) the includes of the file of a statement ($aStmt).
*/
function ImportIncludes($aStmt, $afile)
{
   var Includes = [];
   var id = $aStmt.astId;
    var $currentFunction = getFunctionOrMethod($aStmt);
    var $currentFile = $aStmt.ancestor("file");
    for (var x = 0; x <  $currentFile.astNumChildren ; x++) {
	  var $stmt =  $currentFile.astChild(x);
	  if ($stmt.astId === id) break; 
	  if ($stmt.astName === "IncludeDecl") {
	    TRACE(" ImportIncludes, Include = " + $stmt.code);
 	    Includes.push($stmt);
	  }
	 else
	   if ($stmt.astName === "DeclStmt") {  // 
	     var ch = $stmt.astChild(0);
		 if (ch.astName === "UsingDirectiveDecl") 
		 	Includes.push($stmt);
	 	 }
   }
   // Adding declaration in the original file.
   for (f= Includes.length; f >0; f--) {
       $afile.insertBefore(Includes[f-1].code);
   }
}

/** Declaration of a new method in a class.

   @param $FunctionOrMethod the ast of a function or a method.
   @param nfunc the name of the new function or method to declare.
   @param inter the interface of the function/method to declare.
   
   @return the name to use for the definition. 
   
   If $FunctionOrMethod is a function, the declaration is not added and nfunc is returned,
   for a method a new method is declared in the class of the $FunctionOrMethod method, it returns 
   the string to use for the definition of the new method (ie C::nfunc, where C is the 
   name of the class of $FunctionOrMethod).
 */
function declareNewMethod( $FunctionOrMethod, nfunc, inter)
{
    if (! isaMethod($FunctionOrMethod)) return nfunc;
    var $vdecl = $FunctionOrMethod.declarationJp;
    $vdecl.insert before inter + ';';
    // def for the definition of the method.
    return $FunctionOrMethod.record.name + "::" + nfunc;
}


/**
 Import in a file ($splittedfile) the declaration of the external references of a statement ( $st).
 These declarations are attributed "extern" in the $splittedfile file.
*/
function ImportDeclarations($st, $splittedfile)
{
    var $vcode;
    tabDecl = getExternalDeclsOf($st);
    // Declare same declarations as externals (without initial value) in the new file.
   	for (f in tabDecl) { 
   	  var $elem = tabDecl[f];
   	  // But may introduce a conflict, if it exsists an another global 
   	  // variable with the same name in the application.
   	  if ($elem.storageClass === 'static') $elem.setValue('storageClass', 'NONE');  
      var $vstmt = $elem.copy(); // a varDecl
      if (isAConstantDecl($vstmt)) 
        $vcode =  $vstmt.code + ';';
      else
       	$vcode = "extern " + removeInitDecl($vstmt).code + ';';
      $splittedfile.insertBegin($vcode);
    }
}

/**
  @return a new identifier. 
*/
function getNewId(name)
{
 $SPLIT_CPT_ID++;
 return name + '_' + $SPLIT_NEW_ID + '_' + $SPLIT_CPT_ID;
}

function TRACE_HERE(mess)
{
  if (LOC_DEBUG_MODE)  println(mess); else TRACE(mess);

}


