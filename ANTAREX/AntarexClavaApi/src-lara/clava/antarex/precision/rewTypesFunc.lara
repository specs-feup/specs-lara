import lara.Io;
import clava.Clava;
import clava.ClavaJoinPoints;
import lara.Strings;
import antarex.utils.messages;

// The preserved types (typedef)
var DONTMODIFY=[];

/**
 Initialize the preserved types.
 @param tab an array of names of types to preserved, assumed to be typedef types.
*/
function initPreservedTypes(tab){
  DONTMODIFY=tab;
}

/**
  @return true if the parameter (nametype) is a name of a preserved types, false otherwise.
*/
function isDeclareddDontModify(nametype)
{
  return (DONTMODIFY.indexOf(nametype) > -1);
}

/**
  @return the result of the substitution of a type (oldType) by an other one (newType) 
  in a type expression ($vardeclType).
*/
function getNewType($vardeclType, oldType, newType) {
    if (isDeclareddDontModify($vardeclType.code)) return $vardeclType;
    if ( $vardeclType  === oldType ) return newType;
    if ( $vardeclType.code === oldType.code ) return newType;
    if (ClavaJoinPoints.equals($vardeclType, oldType)) return newType;

    var typeKind = $vardeclType.kind;
    TRACE(" -----------------  getNewType = " + typeKind + ' code = ' + $vardeclType.code);

    if ($vardeclType.astIsInstance("BuiltinType")) return $vardeclType;
    if ($vardeclType.astIsInstance("FunctionProtoType")) return $vardeclType;
    if ($vardeclType.astIsInstance("NullType")) return $vardeclType;
    if ($vardeclType.astIsInstance("AutoType")) return $vardeclType;
    if ($vardeclType.astIsInstance("LiteralType")) return $vardeclType;

    if ( $vardeclType.astIsInstance("ElaboratedType"))        {
        // std::vector<double>  for example.
        TRACE("  ====> ElaboratedType pre = " +  $vardeclType.code );
        var $child= $vardeclType.astChild(0);
        TRACE("  \t ----- ElaboratedType::$child = " +  $child.code );
        var $ntype = getNewType($child, oldType, newType);
        TRACE("  \t ----- ElaboratedType::$child = " +  $child.code );
        $child.setType($ntype); // $child.exec replaceWith($ntype);
        TRACE("  <==== ElaboratedType post " + $vardeclType.code);
        return $vardeclType;
    }

    if ( $vardeclType.astIsInstance("LValueReferenceType")) {
        // TYPE & 
        TRACE(" LValueReferenceType pre = " + $vardeclType.code);
        var $child= $vardeclType.astChild(0);
        var $ntype = getNewType($child, oldType, newType);
        $child.exec replaceWith($ntype);
        TRACE(" LValueReferenceType post = " + $vardeclType.code);
        return $vardeclType; 
    }

    if ( $vardeclType.astIsInstance("QualType")) {
        // TYPE const
        TRACE(" +++> QualType pre = " + $vardeclType.code);
        var $child= $vardeclType.astChild(0);
        TRACE(" LValueReferenceType pre = " + $child.code);
        var $ntype = getNewType($child, oldType, newType);
        $vret = setNewType($vardeclType, $child, $ntype);
        TRACE(" <+++ QualType post = " + $vret.code);
        return $vret;
    }


    if ( $vardeclType.astIsInstance("TemplateSpecializationType")) {
        // vector<double> for example.
        var $argTypes= $vardeclType.templateArgsTypes; 
        TRACE("  >>> TemplateSpecializationType pre = " + $vardeclType.code);
        for (var i=0; i< $argTypes.length; i++)
            {
                var $child = $argTypes[i];
                if ( $child.kind !== 'NullType') {
                    TRACE("  >>> templateArgTypes = " + $child.code);
                    var $ntype = getNewType($child, oldType, newType);
                    TRACE("  <<< templateArgTypes new =  " + $ntype.code);
                    $vardeclType.setTemplateArgsTypes(i, $ntype);
                }
            }
        TRACE( "  <<< TemplateSpecializationType post " + $vardeclType.code);
        return $vardeclType;
    }

    if ( $vardeclType.astIsInstance("SubstTemplateTypeParmType")) {
        TRACE("  >>> SubstTemplateTypeParmType pre = " + $vardeclType.code);
        var Children =  $vardeclType.astChildren;
        for (var x of Children)
            {
                TRACE(" SubstTemplateTypeParmType Child = " + x.code + " kind = " + x.kind);
                var $ntype = getNewType(x, oldType, newType);
                x.exec replaceWith($ntype); // or  x.setType($ntype); ?
                TRACE( " SubstTemplateTypeParmType Child replaced by = " + x.code + 
                       ", but ntype code is = " + $ntype.code);
            }
        TRACE("  >>> SubstTemplateTypeParmType post = " + $vardeclType.code);
        return $vardeclType;
    }

    if ( $vardeclType.astIsInstance("IncompleteArrayType") 
         || $vardeclType.astIsInstance("PointerType")
         || $vardeclType.astIsInstance("ConstantArrayType") 
         || $vardeclType.astIsInstance("ArrayType")
         || $vardeclType.astIsInstance("DecayedType")) {
        var $unwrappedType = $vardeclType.unwrap;
        if($unwrappedType !== undefined) {
            TRACE(" unwrappedType = " + $unwrappedType.code);
            var $ntype = getNewType($unwrappedType, oldType, newType);
            TRACE(" unwrappedType replaced by = " + $ntype.code);
            return setNewType($vardeclType, $unwrappedType, $ntype);
        }
        return $vardeclType; 
    }

    if ($vardeclType.astIsInstance("TypedefType")) {
        var $ntype;
        var $unwrappedType = $vardeclType.unwrap;
        TRACE(" °°°> TypedefType  pre = " + $vardeclType.code);
        if($unwrappedType === undefined) 
            $ntype = $vardeclType;
        else {
            TRACE("\t TypedefType unwrappedType = " + $unwrappedType.code);
            $ntype = getNewType($unwrappedType, oldType, newType);
            TRACE("\t TypedefType unwrappedType replaced by = " + $ntype.code);
            if ( $ntype === undefined ) $ntype = $vardeclType;
        }
        TRACE(" °°°> TypedefType  post = " + $ntype.code);
        return $ntype;
    }

   // if ($vardeclType.astIsInstance("tagType")) return $vardeclType; // LB: Removed 18 April 2018.
    if ($vardeclType.astIsInstance("TemplateTypeParmType")) return $vardeclType;
    if ($vardeclType.astIsInstance("RecordType")) return $vardeclType;
    NYI(" getNewType:: Type not yet analyzed = " + typeKind);
    return $vardeclType; 
}

/**
  Misc function local to getNewType() function.
*/
function setNewType($vardeclType, $child, $ntype ){
    if  (( $ntype !== undefined ) && ( $ntype !== $child)) $child.replaceWith($ntype);
    return $vardeclType;
}



