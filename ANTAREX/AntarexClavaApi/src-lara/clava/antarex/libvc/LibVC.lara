import antarex.libvc.LibVCAspects;

function LibVC ($func, options, name) {
	
	checkDefined($func, '$func', 'LibVC');
	checkJoinPointType($func, 'function', 'LibVC ($func)');
	checkTrue($func.hasDefinition, '$func should be a function definition', 'LibVC');
	
	/* TODO: make name if undefined */
	this._name = name;
	
	/* names of intermediate variables */
	this._compName = this._name + '_compiler';
	this._optListName = this._name + '_opt_list';
	this._builderName = this._name + '_builder';
	this._versionName = this._name + '_version';
	this._symbolName = this._name;
	
	/* function data */
	this._funcName = $func.name;
	this._funcPath = $func.ancestor('file').filepath;
	this._type = '';
	this._typedef = '';
	this._makeType($func);

	/* compiler options for the version */
	this._options = new LibVCOptions();
	
	/* set of files in which we already added headers */
	this._filesWithHeader = {};
	
	/* variables that signal whether dependecies are satisfied */
	this._buildOptionListCalled = false;
	this._buildVersionCalled = false;
	this._compileVersionCalled = false;
	this._loadCalled = false;
	
	/* initialize the library at the start if the main function */
	call _LVC_INIT_(name, this._compName, this);
	
	/* force C linkage for the target function */
	/* $func may no longer be valid from this moment on TODO: check this */
	call _LVC_C_LINKAGE_($func);
}

/**
 * Makes the code for the typedef based on the original function.
 * */
LibVC.prototype._makeType = function($func) {
	
	this._type = this._name + '_ptr_t';
	this._typedef = 'typedef ' + $func.type.code + '(*' + this._type + ') (';
	
	this._typedef += $func.params.map(function($p){
		return $p.code;
	}).join(',');

	this._typedef += ');';
}

/**
 * Adds the LibVC header file if needed.
 * */
LibVC.prototype._includeHeader = function($jp) {
	
	$file = $jp.ancestor('file');
	
	if(this._filesWithHeader[$file.filepath] === undefined) {
		
		$file.exec addInclude('versioningCompiler/Utils.hpp', false);
		this._filesWithHeader[$file.filepath] = true;
	}
}

/**
 * 
 * Sets the options of the LibVC object.
 * 
 * */
LibVC.prototype.setOptions = function(options) {
	
	checkDefined(options, 'options', 'LibVC.setOptions');
	checkInstance(options, LibVCOptions, 'LibVC.setOptions');
	
	this._options = deepClone(options);
}

LibVC.prototype.addOption = function(prefix, value, tag) {

	this._options.addOption(prefix, value, tag);
}

LibVC.prototype.addOptionLiteral = function(prefix, value, tag) {

	this._options.addOptionLiteral(prefix, value, tag);
}

LibVC.prototype.addDefine = function(prefix, value, tag) {

	this._options.addDefine(prefix, value, tag);
}

LibVC.prototype.addDefineLiteral = function(prefix, value, tag) {

	this._options.addDefineLiteral(prefix, value, tag);
}

/* TODO: move this to a LARA library */
function deepClone(obj) {
	if (typeof obj === 'object') {
		var newObj = new obj.__proto__.constructor();
		for (var key in obj) {
			newObj[key] = deepClone(obj[key]);
		}
		return newObj;
	}
	return obj;
}

LibVC.prototype.buildOptionListAfter = function($joinpoint) {
	
	checkJoinPoint($joinpoint, 'buildOptionListAfter ($joinpoint)');
	
	var code = this._makeOptionsCode();
	
	$joinpoint.insert after code;
	
	this._buildOptionListCalled = true;
}

LibVC.prototype.buildOptionListBefore = function($joinpoint) {
	
	checkJoinPoint($joinpoint, 'buildOptionListBefore ($joinpoint)');
	
	var code = this._makeOptionsCode();
	
	$joinpoint.insert before code;
	
	this._buildOptionListCalled = true;
}

LibVC.prototype._makeOptionsCode = function() {
	
	if(this._options._options.length === 0) {
		println('no compilation options were provided to LibVC');
		return;
	}
	
	var optionsList = [];
	var optionsCode = '';
	
	for(var optId in this._options._options) {
		
		var opt = this._options._options[optId];
		
		var singleName = this._name + '_opt_' + optId;
		optionsList.push(singleName);
		
		var singleOpt = 'vc::Option ' + singleName + ' = vc::Option("' + opt.t + '", ' + opt.p;
		if(opt.v !== undefined) {
			
			singleOpt += ', ' + this._makeValueCode(opt);
		} 
		singleOpt += ');';
		
		optionsCode += singleOpt + '\n';
	}
	
	return OptionListTemplate(this._optListName, optionsCode, optionsList);
}

LibVC.prototype._makeValueCode = function(opt) {
	
	if(opt.l) {
		return '"' + opt.v + '"';
	} else {
		throw 'LibVC does not support non-literal options yet';
	}
}

codedef OptionListTemplate(name, optionsCode, optionsList) %{
[[optionsCode]]
vc::opt_list_t [[name]] = {
	[[optionsList]];
};
}%
end

/**
 * 
 * Options object ofr LibVC. This can be set independently and then passed to the main LibVC object.
 * 
 * */
function LibVCOptions() {
	
	this._options = [];
	
	this.addOption = function(prefix, value, tag) {
		prefix = '"' + prefix + '"';
		tag = tag === undefined ? '' : tag;
		this._options.push({p: prefix, v: value, t:tag, l: false});
	};
	
	this.addOptionLiteral = function(prefix, value, tag) {
		prefix = '"' + prefix + '"';
		tag = tag === undefined ? '' : tag;
		this._options.push({p: prefix, v: value, t:tag, l: true});
	};
	
	this.addDefine = function(prefix, value, tag) {
		prefix = '-D' + prefix + (value === undefined ? '' : '=');
		prefix = '"' + prefix + '"';
		tag = tag === undefined ? '' : tag;
		this._options.push({p: prefix, v: value, t:tag, l: false});
	};
	
	this.addDefineLiteral = function(prefix, value, tag) {
		prefix = '-D' + prefix + (value === undefined ? '' : '=');
		prefix = '"' + prefix + '"';
		tag = tag === undefined ? '' : tag;
		this._options.push({p: prefix, v: value, t:tag, l: true});
	};
}

LibVC.prototype.buildVersionAfter = function($joinpoint) {
	
	checkJoinPoint($joinpoint, 'buildVersionAfter ($joinpoint)');
	
	if(this._buildOptionListCalled === false) {
		this.buildOptionListAfter($joinpoint);
	}
	
	var code = BuilderTemplate(this._builderName, this._versionName, this._funcName, this._funcPath, this._compName, this._optListName);
	
	$joinpoint.insert after code;
	
	this._buildVersionCalled = true;
}

LibVC.prototype.buildVersionBefore = function($joinpoint) {
	
	checkJoinPoint($joinpoint, 'buildVersionBefore ($joinpoint)');
	
	if(this._buildOptionListCalled === false) {
		this.buildOptionListBefore($joinpoint);
	}
	
	var code = BuilderTemplate(this._builderName, this._versionName, this._funcName, this._funcPath, this._compName, this._optListName);
	
	$joinpoint.insert before code;
	
	this._buildVersionCalled = true;
}

codedef BuilderTemplate(builderName, versionName, funcName, filePath, compilerName, optListName) %{
vc::Version::Builder [[builderName]];
[[builderName]]._functionName = "[[funcName]]";
[[builderName]]._fileName_src = "[[filePath]]";
[[builderName]]._compiler = [[compilerName]];
[[builderName]]._optionList = [[optListName]];

auto [[versionName]] = [[builderName]].build();
}%
end

LibVC.prototype.compileVersionAfter = function($joinpoint) {
	
	checkJoinPoint($joinpoint, 'compileVersionAfter ($joinpoint)');
	
	if(this._buildVersionCalled === false) {
		this.buildVersionAfter($joinpoint);
	}

	var code = CompileTemplate(this._versionName);
	
	$joinpoint.insert after code;
	
	this._compileVersionCalled = true;
}

LibVC.prototype.compileVersionBefore = function($joinpoint) {
	
	checkJoinPoint($joinpoint, 'compileVersionBefore ($joinpoint)');
	
	if(this._buildVersionCalled === false) {
		this.buildVersionBefore($joinpoint);
	}

	var code = CompileTemplate(this._versionName);
	
	$joinpoint.insert before code;
	
	this._compileVersionCalled = true;
}

codedef CompileTemplate(versionName) %{
auto ok =  [[versionName]]->compile();
}%
end

LibVC.prototype.loadAfter = function($joinpoint, symbolName) {
	
	checkJoinPoint($joinpoint, 'loadAfter ($joinpoint)');
	
	if(symbolName !== undefined) {
		
		this._symbolName = symbolName;
	}
	
	if(this._compileVersionCalled === false) {
		this.compileVersionAfter($joinpoint);
	}

	var code = LoadTemplate(this._symbolName, this._type, this._versionName);
	
	$joinpoint.insert after code;
	
	this._loadCalled = true;
}

LibVC.prototype.loadBefore = function($joinpoint, symbolName) {
	
	checkJoinPoint($joinpoint, 'loadBefore ($joinpoint)');

	if(symbolName !== undefined) {
		
		this._symbolName = symbolName;
	}
	
	if(this._compileVersionCalled === false) {
		this.compileVersionBefore($joinpoint);
	}

	var code = LoadTemplate(this._symbolName, this._typedef, this._type, this._versionName);
	
	$joinpoint.insert before code;
	
	this._loadCalled = true;
}

codedef LoadTemplate(name, typedef, type, versionName) %{
[[typedef]]
kernel_t [[name]] = ([[type]]) [[versionName]]->getSymbol();
}%
end

LibVC.prototype.replaceCall = function($call) {
	
	checkJoinPointType($call, 'call', 'replaceCall ($call)');
	
	if(this._loadCalled === false) {
		this.loadBefore($call);
	}
	
	$call.exec setName(this._symbolName);
}
