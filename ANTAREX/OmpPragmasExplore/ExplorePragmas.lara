import weaver.WeaverJps;
import clava.Clava;
import lara.cmake.CMaker;
import lara.util.ProcessExecutor;


aspectdef ExplorePragmas
	output executionTimes = {} end
	
	var numRuns = 5;
	// Set timeout to 15 seconds
	//var timeout = 15;


	//var clavaData = Clava.getData();
	//var cFlags = clavaData.getFlags();
	var cFlags = "-g -Wall -O3 -mcmodel=medium";
	//var userIncludes = clavaData.getUserIncludes();
	
	println("C flags: " + cFlags);
	//println("User Includes: " + userIncludes);

	// Collect all pragmas
	var ompPragmas = WeaverJps.search('pragma', {name:'omp'}).get();

	// Adding "no pragmas" case as the first element, in order to calculate the timeout
	//ompPragmas.push("serial version");
	var serialVersion = "serial version";
    ompPragmas = [serialVersion].concat(ompPragmas);
	var timeout = undefined; 	

	// For each pragma, create a copy and disable all the others
	for(var ompPragma of ompPragmas) {
		if(ompPragma === serialVersion) {
			println("Testing serial version");
		} else {
			println("Enabling " + ompPragma.location+ " -> " + ompPragma.code);		
		}
				
		var ompPragmaLocation = ompPragma === serialVersion ? serialVersion : ompPragma.location;
		
		// Initialize pragma execution times
		executionTimes[ompPragmaLocation] = [];
		
		Clava.pushAst();
		
		for(var ompPragmaCopy of WeaverJps.search('pragma', {name:'omp'}).get()) {
			if(ompPragmaCopy.location === ompPragmaLocation) {
				println("Found pragma " + ompPragmaCopy.code);
				continue;
			}
			
			ompPragmaCopy.detach();
		}
		
		
		// Compile current AST
		var cmaker = (new CMaker("pragmaExplore"))
						.setGenerator("MinGW Makefiles")
						.setMakeCommand("mingw32-make")
						.addCurrentAst()
						.setPrintToolsOutput(true);

		cmaker.addFlags(cFlags);
		
		var openMPCmakeCode = %{find_package(OpenMP REQUIRED)
		set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${OpenMP_C_FLAGS}" )
		set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${OpenMP_CXX_FLAGS}" )
		set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} ${OpenMP_EXE_LINKER_FLAGS}" )}%;
		
		cmaker.setCustomCMakeCode(openMPCmakeCode);
		
		var cmakeListsFolder = Io.mkdir("cmaker-src");
		var buildFolder = Io.mkdir(cmakeListsFolder, "build");
		var executable = cmaker.build(cmakeListsFolder, buildFolder);
		
		if(timeout === undefined && ompPragma !== serialVersion) {
			throw "Time out is undefined and we are testing pragma '"+ompPragma+"', check if serial version is being executed";
		}

		//println("Executable: " + executable);
		for(var i=0; i<numRuns; ++i) {
			var executor = new ProcessExecutor();
			executor.setTimeUnit("MILLISECONDS");
			if(timeout !== undefined) {
				executor.setTimeout(timeout);
			}
			
			executor.execute(executable);
			
			
			// Set maximum value
			var value = undefined;
			
			// Execution completed correctly, extract value
			if(executor.getReturnValue() === 0) {
				value = Strings.extractValue("Exec time (ms):", executor.getConsoleOutput());
				//throw "Error while executing '"+executable+"': " + executor.getReturnValue();
			} else {
				value = timeout;
			}
		
			executionTimes[ompPragmaLocation].push(value);

			if(timeout === undefined && ompPragma === serialVersion) {
				// Time out is the time of serial execution + 5%
				timeout = value * 1.05;
			}
		}
		
		Clava.popAst();
	}
	
	println("Execution times:");
	printObject(executionTimes);
	Io.writeJson("executionTimes.json", executionTimes);
	
	/*
	select pragma end
	apply
	
	end
	*/
	
	// Create copy, disable all pragmas
	
	// 

end
