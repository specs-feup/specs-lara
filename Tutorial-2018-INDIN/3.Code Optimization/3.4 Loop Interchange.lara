import clava.ClavaJoinPoints;
import clava.Clava;

import lara.Platforms;
import lara.cmake.CMaker;
import lara.code.Timer;
import lara.util.Combinations;
import lara.util.ProcessExecutor;

aspectdef LoopInterchange

	var controlVars = ["i", "j", "l"];
	var executionResults = {};
	
	var combs = new Combinations(controlVars, 2);
	while(combs.hasNext()) {
		Clava.pushAst();

		// Get next combination
		var interchangePair = combs.next();
		println("Testing interchange " + interchangePair);

		call Interchange(interchangePair[0], interchangePair[1]);
		
		call MeasureTime();

		var id = "interchange_" + interchangePair;
		var executor = compileAndExecute(id);
		executionResults[id] = executor.getConsoleOutput();
		
		Clava.popAst();
	}

	println("Testing original code");
	call MeasureTime();
	var id = "original";
	var executor = compileAndExecute(id);
	executionResults[id] = executor.getConsoleOutput();	
	
	println("Results:");
	printObject(executionResults);
		
end

aspectdef Interchange
	input firstVar, secondVar end

	// Find the top-level loop
	select function{'matrix_mult'}.pragma{"loop1"}.target end
	apply
		var $firstLoop = getLoop($target, firstVar);
		var $secondLoop = getLoop($target, secondVar);

		$firstLoop.interchange($secondLoop);

		//println("LOOP INTERCHANGED:" + $target.code);
	end

end

function getLoop($start, index) {
	for(var $loop of $start.descendantsAndSelf("loop")) {
		if($loop.controlVar === index) {
			return $loop;
		}
	}
	
	return undefined;
}

aspectdef MeasureTime

	var timer = new Timer();

	select function{'matrix_mult'}.pragma{"loop1"}.target end
	apply
		timer.time($target);
		//println("FUNCTION:\n" + $function.code);
	end

end


function compileAndExecute(id) {
	var cmaker = (new CMaker(id)).addCurrentAst();

	if(Platforms.isWindows()) {
		cmaker.setGenerator("MinGW Makefiles").setMakeCommand("mingw32-make");
	}
		
	var executable = cmaker.build();
	var executor = new ProcessExecutor();
	executor.setTimeout(20); // 20 seconds
	executor.execute(executable);

	return executor;
}