import lat.Lat;
import lat.vars.LatVarOmpThreads;
import clava.Clava;


aspectdef Exploration

	
	
	//var bs1 = new LatVarRange("BS1", LatConst.L1_CACHE_LINESIZE, 16 * LatConst.L1_CACHE_LINESIZE, LatConst.L1_CACHE_LINESIZE / 2);
	//var bs2 = new LatVarRange("BS2", LatConst.L1_CACHE_LINESIZE, 16 * LatConst.L1_CACHE_LINESIZE, LatConst.L1_CACHE_LINESIZE / 2);

	//var bs1 = new LatVarRange("BS1", LatConst.L1_CACHE_LINESIZE, 2 * LatConst.L1_CACHE_LINESIZE, LatConst.L1_CACHE_LINESIZE / 2);
	//var bs2 = new LatVarRange("BS2", LatConst.L1_CACHE_LINESIZE, 2 * LatConst.L1_CACHE_LINESIZE, LatConst.L1_CACHE_LINESIZE / 2);
	//var latVars = [bs1, bs2];

	var threadRange = new LatVarRange("dummy", 1, 5, 1);
	var ompThreads = new LatVarOmpThreads(threadRange);
	var latVars = [ompThreads];
	
	select function{"test_matrix_mul"}.call{"matrix_mult"} end
	apply
		call Dse($call, latVars);
	end


end


aspectdef Dse

	input $call, latVars end

	$function = $call.definition;
	if($function === undefined) {
		println("Could not find definition of call@" + $call.location);
		return;
	}


	var lat = new Lat("dse");
	
	// Setup Lat, get CMaker
	var cmaker = lat.setVerbose(true).loadCmaker().cmaker;
	cmaker.addFlags("-fopenmp");
	
	if(Platforms.isWindows()) {
		cmaker.setGenerator("MinGW Makefiles").setMakeCommand("mingw32-make");
	}
	
		
	lat.setScope($function.body);
	lat.setMeasure($call); 

	lat.addSearchGroup(latVars);
	
	lat.tune();

end

